package main

import (
	"bytes"
	"encoding/csv"
	"errors"
	"go/format"
	"io"
	"log"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"text/template"

	"github.com/magefile/mage/mg"
)

var codeTemplate = `
// Code generated by "mage build"; DO NOT EDIT.
package oui

const (
{{- range .Entries }}
	vendor{{ .OUI }} = "{{ .Vendor }}"
{{- end }}
)

var ouis = map[string]string{
{{- range .Entries }}
"{{ .OUI }}": vendor{{ .OUI }}, // {{ .Vendor }}
{{- end }}
}
`

type templateData struct {
	Entries []entry
}

type OUI string

type entry struct {
	OUI    OUI
	Vendor string
}

func (o OUI) String() string {
	return string(o)
}

func (o OUI) Int() int64 {
	n, err := strconv.ParseInt(o.String(), 16, 64)
	if err != nil {
		panic(err)
	}

	return n
}

func generate(src, dst string) error {
	mg.Deps(download)

	fin, err := os.Open(src)
	if err != nil {
		return err
	}
	defer fin.Close()

	data := newTemplateData(fin)

	tmpl, err := template.New("oui").Parse(codeTemplate)
	if err != nil {
		return err
	}

	var buf bytes.Buffer

	if err := tmpl.ExecuteTemplate(&buf, "oui", data); err != nil {
		return err
	}

	fout, err := os.Create(dst)
	if err != nil {
		return err
	}

	defer fout.Close()

	code, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	if _, err := fout.Write(code); err != nil {
		// if _, err := fout.Write(buf.Bytes()); err != nil {
		return err
	}

	return nil
}

func newTemplateData(r io.Reader) *templateData {
	var entries []entry

	ouiMap := make(map[string]string)

	c := csv.NewReader(r)

	_, err := c.Read() // skip header
	if err != nil {
		panic(err)
	}

	for {
		record, err := c.Read()
		if errors.Is(err, io.EOF) {
			break
		}

		if err != nil {
			panic(err)
		}

		o := strings.ToLower(record[1])

		vendor := strings.TrimSpace(record[2])
		vendor = strings.ReplaceAll(vendor, `"`, "")
		vendor = simplifyName(vendor)

		if prev, ok := ouiMap[o]; ok { // 080030 is a known duplicate
			log.Printf("Warning %q:%q is already registered to %q", o, vendor, prev)

			continue
		}

		ouiMap[o] = vendor

		entries = append(entries, entry{OUI: OUI(o), Vendor: vendor})
	}

	sort.Slice(entries, func(i, j int) bool {
		return entries[i].OUI.Int() < entries[j].OUI.Int()
	})

	return &templateData{
		Entries: entries,
	}
}

var (
	llcRegex  = regexp.MustCompile(`(?i),?\s*(llc|ltd|limited|inc|incorporated)\.?$`)
	coRegex   = regexp.MustCompile(`(?i),?\s*(co|company|corp|corporation)\.?$`)
	gmbhRegex = regexp.MustCompile(`(?i),?\s*gmbh\.?$`)
)

func simplifyName(name string) string {
	b := []byte(name)

	b = llcRegex.ReplaceAll(b, []byte{})
	b = coRegex.ReplaceAll(b, []byte{})
	b = gmbhRegex.ReplaceAll(b, []byte{})

	return string(b)
}
